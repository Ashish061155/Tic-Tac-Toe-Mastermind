<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Tic-Tac-Toe - Unbeatable AI</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f172a 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e2e8f0;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .game-container {
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            width: 100%;
            max-width: 500px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #8b5cf6, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 1;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
            position: relative;
            z-index: 1;
        }

        .control-group {
            background: rgba(55, 65, 81, 0.5);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .control-group h3 {
            font-size: 0.9rem;
            color: #a78bfa;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
        }

        button {
            background: linear-gradient(135deg, #374151, #4b5563);
            color: #e5e7eb;
            border: 1px solid rgba(139, 92, 246, 0.4);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.9rem;
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: linear-gradient(135deg, #4b5563, #6b7280);
            border-color: #8b5cf6;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        button.active {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            border-color: #a78bfa;
            color: white;
        }

        button:active {
            transform: translateY(0);
        }

        .restart-btn {
            width: 100%;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            margin-top: 1rem;
            font-weight: 600;
        }

        .restart-btn:hover {
            background: linear-gradient(135deg, #f87171, #ef4444);
            border-color: #f87171;
        }

        .status {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            min-height: 1.5rem;
            color: #a78bfa;
            text-shadow: 0 0 10px rgba(167, 139, 250, 0.3);
            position: relative;
            z-index: 1;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-width: 320px;
            margin: 0 auto 1.5rem;
            background: rgba(17, 24, 39, 0.8);
            padding: 12px;
            border-radius: 16px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            position: relative;
            z-index: 1;
        }

        .cell {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #374151, #4b5563);
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 80px;
        }

        .cell:hover:not(.occupied) {
            background: linear-gradient(135deg, #4b5563, #6b7280);
            border-color: #8b5cf6;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.4);
        }

        .cell.occupied {
            cursor: not-allowed;
        }

        .cell.player-x {
            color: #3b82f6;
            text-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        .cell.player-o {
            color: #ef4444;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        .cell.winning {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(59, 130, 246, 0.3));
            border-color: #a78bfa;
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
            }
            to {
                box-shadow: 0 0 40px rgba(139, 92, 246, 0.8), 0 0 60px rgba(59, 130, 246, 0.4);
            }
        }

        .cell-content {
            animation: placepiece 0.3s ease-out;
            transform-origin: center;
        }

        @keyframes placepiece {
            0% {
                transform: scale(0) rotate(180deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(90deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .game-container {
                margin: 1rem;
                padding: 1.5rem;
            }

            h1 {
                font-size: 2rem;
            }

            .controls {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }

            .cell {
                font-size: 1.8rem;
                min-height: 70px;
            }

            .game-board {
                max-width: 280px;
            }

            .status {
                font-size: 1.1rem;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                margin: 0.5rem;
                padding: 1rem;
            }

            h1 {
                font-size: 1.8rem;
                margin-bottom: 1rem;
            }

            .cell {
                font-size: 1.6rem;
                min-height: 60px;
            }

            .game-board {
                max-width: 240px;
                gap: 6px;
                padding: 8px;
            }

            button {
                padding: 0.6rem 0.8rem;
                font-size: 0.8rem;
            }
        }

        /* Loading and thinking indicators */
        .thinking {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        /* Win line overlay */
        .win-line {
            position: absolute;
            background: linear-gradient(90deg, #8b5cf6, #3b82f6);
            border-radius: 4px;
            animation: drawLine 0.5s ease-out;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.8);
            z-index: 2;
        }

        @keyframes drawLine {
            0% {
                transform: scale(0);
            }
            100% {
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Advanced Tic-Tac-Toe</h1>
        
        <div class="controls">
            <div class="control-group">
                <h3>Your Symbol</h3>
                <div class="button-group">
                    <button id="choose-x" class="active">X</button>
                    <button id="choose-o">O</button>
                </div>
            </div>
            <div class="control-group">
                <h3>First Player</h3>
                <div class="button-group">
                    <button id="player-first" class="active">You</button>
                    <button id="ai-first">AI</button>
                </div>
            </div>
        </div>

        <div class="status" id="status">Choose your settings and click restart to play!</div>
        
        <div class="game-board" id="board">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>

        <button class="restart-btn" id="restart">Start New Game</button>
    </div>

    <script>
        /**
         * Advanced Tic-Tac-Toe Game with Unbeatable AI
         * Uses Minimax algorithm with Alpha-Beta pruning
         */
        class TicTacToe {
            constructor() {
                // Game state variables
                this.board = Array(9).fill(''); // Empty 3x3 board
                this.currentPlayer = 'X'; // Current player (X or O)
                this.playerSymbol = 'X'; // What symbol the human player uses
                this.aiSymbol = 'O'; // What symbol the AI uses
                this.playerFirst = true; // Whether player goes first
                this.gameOver = false; // Game state flag
                this.aiThinking = false; // AI thinking state
                
                // DOM elements
                this.boardElement = document.getElementById('board');
                this.statusElement = document.getElementById('status');
                this.cells = document.querySelectorAll('.cell');
                this.chooseXBtn = document.getElementById('choose-x');
                this.chooseOBtn = document.getElementById('choose-o');
                this.playerFirstBtn = document.getElementById('player-first');
                this.aiFirstBtn = document.getElementById('ai-first');
                this.restartBtn = document.getElementById('restart');

                // Winning combinations (indices of board array)
                this.winningCombos = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns  
                    [0, 4, 8], [2, 4, 6] // Diagonals
                ];

                this.initializeGame();
            }

            /**
             * Initialize the game by setting up event listeners and initial state
             */
            initializeGame() {
                this.setupEventListeners();
                this.updateStatus('Choose your settings and click restart to play!');
                this.disableBoard();
            }

            /**
             * Set up all event listeners for the game
             */
            setupEventListeners() {
                // Cell click handlers
                this.cells.forEach(cell => {
                    cell.addEventListener('click', (e) => this.handleCellClick(e));
                });

                // Control button handlers
                this.chooseXBtn.addEventListener('click', () => this.setPlayerSymbol('X'));
                this.chooseOBtn.addEventListener('click', () => this.setPlayerSymbol('O'));
                this.playerFirstBtn.addEventListener('click', () => this.setFirstPlayer(true));
                this.aiFirstBtn.addEventListener('click', () => this.setFirstPlayer(false));
                this.restartBtn.addEventListener('click', () => this.restartGame());
            }

            /**
             * Set which symbol the player will use (X or O)
             */
            setPlayerSymbol(symbol) {
                this.playerSymbol = symbol;
                this.aiSymbol = symbol === 'X' ? 'O' : 'X';
                
                // Update button states
                this.chooseXBtn.classList.toggle('active', symbol === 'X');
                this.chooseOBtn.classList.toggle('active', symbol === 'O');
                
                this.playSound('click');
            }

            /**
             * Set who goes first (player or AI)
             */
            setFirstPlayer(playerFirst) {
                this.playerFirst = playerFirst;
                
                // Update button states
                this.playerFirstBtn.classList.toggle('active', playerFirst);
                this.aiFirstBtn.classList.toggle('active', !playerFirst);
                
                this.playSound('click');
            }

            /**
             * Handle cell clicks during gameplay
             */
            handleCellClick(event) {
                const index = parseInt(event.target.dataset.index);
                
                // Ignore clicks if game is over, AI is thinking, or cell is occupied
                if (this.gameOver || this.aiThinking || this.board[index] !== '') {
                    return;
                }

                // Only allow player moves when it's their turn
                if (this.currentPlayer === this.playerSymbol) {
                    this.makeMove(index, this.playerSymbol);
                }
            }

            /**
             * Execute a move on the board
             */
            makeMove(index, player) {
                // Update board state
                this.board[index] = player;
                this.updateCell(index, player);
                
                // Play appropriate sound
                this.playSound(player === this.playerSymbol ? 'playerMove' : 'aiMove');

                // Check for game end conditions
                const winner = this.checkWinner();
                if (winner) {
                    this.endGame(winner);
                    return;
                }

                if (this.isBoardFull()) {
                    this.endGame('draw');
                    return;
                }

                // Switch to next player
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                this.updateGameState();
            }

            /**
             * Update the visual representation of a cell
             */
            updateCell(index, player) {
                const cell = this.cells[index];
                const content = document.createElement('div');
                content.className = 'cell-content';
                content.textContent = player;
                
                cell.innerHTML = '';
                cell.appendChild(content);
                cell.classList.add('occupied', player === 'X' ? 'player-x' : 'player-o');
            }

            /**
             * Update game state and handle AI turns
             */
            updateGameState() {
                if (this.gameOver) return;

                if (this.currentPlayer === this.playerSymbol) {
                    this.updateStatus('Your turn');
                } else {
                    this.updateStatus('AI thinking...', true);
                    this.aiThinking = true;
                    
                    // Add delay for AI move to simulate thinking
                    setTimeout(() => {
                        if (!this.gameOver) {
                            this.makeAIMove();
                        }
                    }, Math.random() * 200 + 300); // 300-500ms delay
                }
            }

            /**
             * Execute AI move using Minimax algorithm
             */
            makeAIMove() {
                const bestMove = this.getBestMove();
                this.aiThinking = false;
                this.makeMove(bestMove, this.aiSymbol);
            }

            /**
             * Get the best possible move for AI using Minimax with Alpha-Beta pruning
             * This ensures the AI is unbeatable
             */
            getBestMove() {
                let bestScore = -Infinity;
                let bestMove = 0;

                // Try each empty cell to find the best move
                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === '') {
                        // Simulate the move
                        this.board[i] = this.aiSymbol;
                        
                        // Calculate score using minimax with alpha-beta pruning
                        let score = this.minimax(this.board, 0, false, -Infinity, Infinity);
                        
                        // Undo the simulated move
                        this.board[i] = '';
                        
                        // Update best move if this score is better
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = i;
                        }
                    }
                }

                return bestMove;
            }

            /**
             * Minimax algorithm with Alpha-Beta pruning
             * This is the core AI logic that ensures perfect play
             * 
             * @param {Array} board - Current board state
             * @param {number} depth - Current search depth
             * @param {boolean} isMaximizing - Whether we're maximizing or minimizing
             * @param {number} alpha - Alpha value for pruning
             * @param {number} beta - Beta value for pruning
             * @returns {number} - Score of the position
             */
            minimax(board, depth, isMaximizing, alpha, beta) {
                // Check if game has ended
                const winner = this.checkWinnerForBoard(board);
                
                // Base cases - return scores for terminal positions
                if (winner === this.aiSymbol) {
                    return 10 - depth; // AI wins (prefer quicker wins)
                }
                if (winner === this.playerSymbol) {
                    return depth - 10; // Player wins (prefer slower losses)
                }
                if (this.isBoardFullForBoard(board)) {
                    return 0; // Draw
                }

                if (isMaximizing) {
                    // AI's turn - maximize score
                    let maxScore = -Infinity;
                    
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            // Try AI move
                            board[i] = this.aiSymbol;
                            let score = this.minimax(board, depth + 1, false, alpha, beta);
                            board[i] = ''; // Undo move
                            
                            maxScore = Math.max(score, maxScore);
                            alpha = Math.max(alpha, score);
                            
                            // Alpha-Beta pruning - cut off search if beta <= alpha
                            if (beta <= alpha) {
                                break;
                            }
                        }
                    }
                    return maxScore;
                } else {
                    // Player's turn - minimize score
                    let minScore = Infinity;
                    
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            // Try player move
                            board[i] = this.playerSymbol;
                            let score = this.minimax(board, depth + 1, true, alpha, beta);
                            board[i] = ''; // Undo move
                            
                            minScore = Math.min(score, minScore);
                            beta = Math.min(beta, score);
                            
                            // Alpha-Beta pruning - cut off search if beta <= alpha
                            if (beta <= alpha) {
                                break;
                            }
                        }
                    }
                    return minScore;
                }
            }

            /**
             * Check for winner in current board state
             */
            checkWinner() {
                return this.checkWinnerForBoard(this.board);
            }

            /**
             * Check for winner in any board state (used by minimax)
             */
            checkWinnerForBoard(board) {
                // Check each winning combination
                for (let combo of this.winningCombos) {
                    const [a, b, c] = combo;
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                        return board[a];
                    }
                }
                return null;
            }

            /**
             * Check if the current board is full
             */
            isBoardFull() {
                return this.isBoardFullForBoard(this.board);
            }

            /**
             * Check if any board is full (used by minimax)
             */
            isBoardFullForBoard(board) {
                return board.every(cell => cell !== '');
            }

            /**
             * End the game with a result
             */
            endGame(result) {
                this.gameOver = true;
                
                if (result === 'draw') {
                    this.updateStatus("It's a draw!");
                    this.playSound('draw');
                } else if (result === this.playerSymbol) {
                    this.updateStatus('You win! 🎉');
                    this.playSound('win');
                    this.highlightWinningCells();
                } else {
                    this.updateStatus('AI wins! 🤖');
                    this.playSound('lose');
                    this.highlightWinningCells();
                }
                
                this.disableBoard();
            }

            /**
             * Highlight the winning combination of cells
             */
            highlightWinningCells() {
                for (let combo of this.winningCombos) {
                    const [a, b, c] = combo;
                    if (this.board[a] && this.board[a] === this.board[b] && this.board[a] === this.board[c]) {
                        this.cells[a].classList.add('winning');
                        this.cells[b].classList.add('winning');
                        this.cells[c].classList.add('winning');
                        break;
                    }
                }
            }

            /**
             * Update the status message
             */
            updateStatus(message, thinking = false) {
                this.statusElement.textContent = message;
                this.statusElement.classList.toggle('thinking', thinking);
            }

            /**
             * Disable the game board (prevent clicks)
             */
            disableBoard() {
                this.boardElement.style.pointerEvents = 'none';
            }

            /**
             * Enable the game board (allow clicks)
             */
            enableBoard() {
                this.boardElement.style.pointerEvents = 'auto';
            }

            /**
             * Restart the game with current settings
             */
            restartGame() {
                // Reset game state
                this.board = Array(9).fill('');
                this.gameOver = false;
                this.aiThinking = false;
                
                // Determine who goes first based on settings
                this.currentPlayer = this.playerFirst ? this.playerSymbol : this.aiSymbol;
                
                // Clear board visually
                this.cells.forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('occupied', 'player-x', 'player-o', 'winning');
                });

                // Enable the board and start the game
                this.enableBoard();
                this.playSound('start');
                
                // If AI goes first, make AI move
                if (!this.playerFirst) {
                    this.updateStatus('AI starts first...');
                    setTimeout(() => {
                        if (!this.gameOver) {
                            this.makeAIMove();
                        }
                    }, 500);
                } else {
                    this.updateStatus('Your turn');
                }
            }

            /**
             * Play sound effects using Web Audio API
             * Creates synthetic sounds for different game events
             */
            playSound(type) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Different sounds for different events
                    switch(type) {
                        case 'playerMove':
                            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                            oscillator.start();
                            oscillator.stop(audioContext.currentTime + 0.1);
                            break;
                        case 'aiMove':
                            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                            oscillator.start();
                            oscillator.stop(audioContext.currentTime + 0.15);
                            break;
                        case 'win':
                            // Play ascending chord for win
                            [523, 659, 784].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(audioContext.destination);
                                osc.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.1);
                                gain.gain.setValueAtTime(0.1, audioContext.currentTime + i * 0.1);
                                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3 + i * 0.1);
                                osc.start(audioContext.currentTime + i * 0.1);
                                osc.stop(audioContext.currentTime + 0.3 + i * 0.1);
                            });
                            break;
                        case 'lose':
                            // Play descending notes for loss
                            [400, 350, 300].forEach((freq, i) => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(audioContext.destination);
                                osc.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.15);
                                gain.gain.setValueAtTime(0.1, audioContext.currentTime + i * 0.15);
                                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2 + i * 0.15);
                                osc.start(audioContext.currentTime + i * 0.15);
                                osc.stop(audioContext.currentTime + 0.2 + i * 0.15);
                            });
                            break;
                        case 'draw':
                            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            oscillator.start();
                            oscillator.stop(audioContext.currentTime + 0.3);
                            break;
                        case 'click':
                            oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                            oscillator.start();
                            oscillator.stop(audioContext.currentTime + 0.05);
                            break;
                        case 'start':
                            oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                            oscillator.start();
                            oscillator.stop(audioContext.currentTime + 0.2);
                            break;
                    }
                } catch (e) {
                    // Fallback if Web Audio API is not supported
                    console.log('Audio not supported');
                }
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TicTacToe();
        });
    </script>
</body>
</html>